---
title: "Xenium mouse brain - three replicates"
author: "Melody Jin"
date: "2025-09-29"
output: workflowr::wflow_html
---

```{r global-options, include = FALSE}
options(width = 80, digits = 3) # output length

knitr::opts_chunk$set(cache = FALSE,echo = TRUE,prompt = FALSE, 
                      comment = NA,message = FALSE,warning = FALSE,
                      fig.align = "center", fig.keep= "all",
                      fig.show ="hold")

```

```{r load-lib}
library(spatstat)
library(jazzPanda)
library(SpatialExperiment)
library(Seurat)
library(ggplot2)
library(data.table)
library(dplyr)
library(glmnet)
library(caret)
library(ComplexUpset)
library(corrplot)
library(gridExtra)
library(patchwork)
library(RColorBrewer)
library(ggvenn)
library(limma)
library(edgeR)
library(speckle)
library(clustree)
library(xtable)

library(here)
source(here("code/utils.R"))
library(Banksy)
library(harmony)
```
# Load the data
```{r load-raw}
data_nm  <- "xenium_mbrain"
rep1=get_xenium_data(path=rdata$xmb_r1, 
                     mtx_name = "cell_feature_matrix/",
                     trans_name = "transcripts.csv.gz",
                     cells_name="cells.csv.gz")

rep2=get_xenium_data(path=rdata$xmb_r2,
                     mtx_name = "cell_feature_matrix/",
                     trans_name = "transcripts.csv.gz",
                     cells_name="cells.csv.gz")

rep3=get_xenium_data(path=rdata$xmb_r3,
                     mtx_name = "cell_feature_matrix/",
                     trans_name = "transcripts.csv.gz",
                     cells_name="cells.csv.gz")

rep1$trans_info = rep1$trans_info[rep1$trans_info$qv >=20 & 
                                      rep1$trans_info$cell_id != -1 & 
                                      !(rep1$trans_info$cell_id %in% rep1$zero_cells), ]
rep2$trans_info = rep2$trans_info[rep2$trans_info$qv >=20 &  
                                      rep2$trans_info$cell_id != -1 & 
                                      !(rep2$trans_info$cell_id %in% rep2$zero_cells), ]
rep3$trans_info = rep3$trans_info[rep3$trans_info$qv >=20 & 
                                      rep3$trans_info$cell_id != -1 & 
                                      !(rep3$trans_info$cell_id %in% rep3$zero_cells), ]


```

```{r load-cm, fig.width = 8, fig.height=6}
cm1 = rep1$cm
colnames(cm1) = paste("r1-", colnames(cm1), sep="")

cm2 = rep2$cm
colnames(cm2) = paste("r2-", colnames(cm2), sep="")

cm3 = rep3$cm
colnames(cm3) = paste("r3-", colnames(cm3), sep="")
```

# Single cell summary

These summary plots characterise per-cell detection counts and sparsity. We can calculate per-cell and per-gene summary statistics from the counts matrix:

- Total detections per cell: sums all transcript counts in each cell.

- Proportion of zeroes per cell: fraction of genes not detected in each cell.

- Detected genes per cell: number of non-zero genes per cell.

- Average expression per gene: mean expression across cells, ignoring zeros.

Each distribution is visualised with histograms and density curves to assess data quality and sparsity.

```{r sc_output}
td_r1 <- colSums(cm1)
pz_r1 <- colMeans(cm1==0)
numgene_r1 <- colSums(cm1!=0)

td_r2 <- colSums(cm2)
pz_r2 <- colMeans(cm2==0)
numgene_r2 <- colSums(cm2!=0)

td_r3 <- colSums(cm3)
pz_r3 <- colMeans(cm3==0)
numgene_r3 <- colSums(cm3!=0)


# Build the entire summary as one string
output <- paste0(
  "\n================= Summary Statistics =================\n\n",
  "--- Replicate 1 ---\n",
  make_sc_summary(td_r1, "Total detections per cell:"),
  make_sc_summary(pz_r1, "Proportion of zeroes per cell:"),
  make_sc_summary(numgene_r1, "Detected genes per cell:"),
  "\n---Replicate 2 ---\n",
  make_sc_summary(td_r2, "Total detections per cell:"),
  make_sc_summary(pz_r2, "Proportion of zeroes per cell:"),
  make_sc_summary(numgene_r2, "Detected genes per cell:"),
  "\n--- Replicate 3 ---\n",
  make_sc_summary(td_r3, "Total detections per cell:"),
  make_sc_summary(pz_r3, "Proportion of zeroes per cell:"),
  make_sc_summary(numgene_r3, "Detected genes per cell:"),
  "\n========================================================\n"
)

cat(output)

```

```{r sc_summary, fig.height=9, fig.width=6}

td = as.data.frame(rbind(cbind(as.vector(td_r1),rep("replicate1", length(td_r1))),
                cbind(as.vector(td_r2),rep("replicate2", length(td_r2))), 
                cbind(as.vector(td_r3),rep("replicate3", length(td_r3)))))
colnames(td) = c("td","replicate")
td$td= as.numeric(td$td)

p1<-ggplot(data = td, aes(x = td, color=replicate)) +
  geom_histogram(aes(y = after_stat(density)), 
                 binwidth = 100, fill = "gray", color = "black") +
  geom_density(color = "steelblue", size = 2) +
  facet_wrap(~replicate)+
  labs(title = "Distribution of total detections per cell",
       x = " ", y = "Density") +
  #xlim(0, 1000) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5), 
        strip.text = element_text(size=12)) 

pz = as.data.frame(rbind(cbind(as.vector(pz_r1),rep("replicate1", length(pz_r1))),
                cbind(as.vector(pz_r2),rep("replicate2", length(pz_r2))), 
                cbind(as.vector(pz_r3),rep("replicate3", length(pz_r3)))))
colnames(pz) = c("prop_ze","replicate")
pz$prop_ze= as.numeric(pz$prop_ze)

p2<-ggplot(data = pz, aes(x = prop_ze, color=replicate)) +
  geom_histogram(aes(y = after_stat(density)), 
                 binwidth = 0.05, fill = "gray", color = "black") +
  geom_density(color = "steelblue", size = 2) +
  facet_wrap(~replicate)+
  labs(title = "Distribution of proportion of zeroes per cell",
       x = " ", y = "Density") +
  #xlim(0, 1) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        strip.text = element_text(size=12))


numgens = as.data.frame(rbind(cbind(as.vector(numgene_r1),rep("replicate1", length(numgene_r1))),
                cbind(as.vector(numgene_r2),rep("replicate2", length(numgene_r2))), 
                cbind(as.vector(numgene_r3),rep("replicate3", length(numgene_r3)))))
colnames(numgens) = c("numgen","replicate")
numgens$numgen= as.numeric(numgens$numgen)

p3<-ggplot(data = numgens, aes(x = numgen, color=replicate)) +
  geom_histogram(aes(y = after_stat(density)), 
                 binwidth = 10, fill = "gray", color = "black") +
  geom_density(color = "steelblue", size = 2) +
  facet_wrap(~replicate)+
  labs(title = "Distribution of detected genes per cell",
       x = " ", y = "Density") +
  #xlim(0, 1) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        strip.text = element_text(size=12))




layout_design <- p1/p2/p3

layout_design <- layout_design + 
                 patchwork::plot_layout(widths = c(1, 1,1), heights = c(1, 1 ,1)) 

layout_design

```


```{r ave-expression, fig.width=6, fig.height=3}
cm_new1=cm1
cm_new1[cm_new1==0] = NA
cm_new1 = as.data.frame(cm_new1)
cm_new1$avg2 = rowMeans(cm_new1,na.rm = TRUE)
summary(cm_new1$avg2)
cm_new2=cm2
cm_new2[cm_new2==0] = NA
cm_new2 = as.data.frame(cm_new2)
cm_new2$avg2 = rowMeans(cm_new2,na.rm = TRUE)
summary(cm_new2$avg2)
cm_new3=cm3
cm_new3[cm_new3==0] = NA
cm_new3 = as.data.frame(cm_new3)
cm_new3$avg2 = rowMeans(cm_new3,na.rm = TRUE)
summary(cm_new3$avg2)
avg_exp = as.data.frame(cbind("avg"=c(cm_new1$avg2, cm_new2$avg2, cm_new3$avg2),
                             "sample"=c(rep("replicate1", nrow(cm1)), 
                               rep("replicate2", nrow(cm2)), 
                               rep("replicate3", nrow(cm3)) )))

avg_exp$avg=as.numeric(avg_exp$avg)
avg_exp$sample = factor(avg_exp$sample,
                        levels = c("replicate1", "replicate2","replicate3"))

ggplot(data = avg_exp, aes(x = avg, color=sample)) +
  geom_histogram(aes(y = after_stat(density)), 
                 binwidth = 0.5, fill = "gray", color = "black") +
  geom_density(color = "orange", linewidth = 1) +
  facet_wrap(~sample)+
  labs(title = "Distribution of average gene expression per cell",
       x = " ", y = "Density") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        strip.text = element_text(size=12))

```

The three replicates show highly similar distributions. The median total detections per cell range from 250–253, and the median number of detected genes is around 80. The median proportion of zero counts is about 0.67–0.68. The average gene expression is about 2.59, 2.63, and 2.66 for replciate 1, 2 and 3. 

# Quality assessment of negative controls
## Negative control probes

Negative control probes are non-targeting probes designed not to hybridize to any transcript. A total of 27 negative control probe targets were included in this dataset, with median total detections of approximately 1078, 831, and 779 for replicates 1, 2, and 3, respectively. There are no particular localised patterns for these probes. 
```{r nc_probe, fig.width=12, fig.height=10}
probe_coords <- as.data.frame(rbind(cbind(sample="replicate1",rep1$trans_info[rep1$trans_info$feature_name %in% rep1$probe, c("feature_name","x","y")]),
                                        cbind(sample="replicate2",rep2$trans_info[rep2$trans_info$feature_name %in% rep2$probe, c("feature_name","x","y")]),
                                        cbind(sample="replicate3",rep3$trans_info[rep3$trans_info$feature_name %in% rep3$probe, c("feature_name","x","y")])
                                        ))

codeword_coords <- as.data.frame(rbind(cbind(sample="replicate1",rep1$trans_info[rep1$trans_info$feature_name %in% rep1$codeword, c("feature_name","x","y")]),
                                        cbind(sample="replicate2",rep2$trans_info[rep2$trans_info$feature_name %in% rep2$codeword, c("feature_name","x","y")]),
                                        cbind(sample="replicate3",rep3$trans_info[rep3$trans_info$feature_name %in% rep3$codeword, c("feature_name","x","y")])
                                        ))
ordered_feature = probe_coords %>% group_by(feature_name) %>% count() %>% arrange(desc(n))%>% pull(feature_name) 
probe_tb = as.data.frame(probe_coords %>% group_by(sample, feature_name) %>% count())
colnames(probe_tb) = c("sample","feature_name","value_count")
probe_tb$feature_name = factor(probe_tb$feature_name, levels= ordered_feature)

probe_tb = probe_tb[order(probe_tb$feature_name), ]

ggplot(probe_tb, aes(x = feature_name, y = value_count)) +
    geom_bar(stat = "identity", position = position_dodge()) + 
    facet_wrap(~sample, ncol=1, scales = "free_y")+
    labs(title = " ", x = " ", y = "Number of total detections") +
    theme_bw()+
   theme(legend.position = "none",
          axis.text.x= element_text(size=8, angle=45,vjust=1,hjust = 1),
          axis.text.y=element_text(size=10),
          axis.ticks=element_blank(),
          strip.text = element_text(size=12),
          axis.title.y = element_text(size=12),
          axis.title.x=element_blank(),
          strip.background = element_rect(fill="white", colour ="black"),
          panel.background=element_blank(),
          panel.grid.minor=element_blank(),
          plot.background=element_blank())

```

```{r neg_probe_xy, fig.height=5, fig.width=9}
p1<-ggplot(probe_coords, aes(x = x, y = y)) +
            geom_hex(bins = auto_hex_bin(min(table(probe_coords$sample)), 
                                         target_points_per_bin = 1)) +
            theme_bw() +
            scale_fill_gradient(low = "white", high = "black") +
            guides(fill = guide_colorbar(barheight = unit(0.06, "npc"),
                                         barwidth  = unit(0.4, "npc"),
                                         )) +
            scale_x_reverse()+
            facet_grid(~sample) +
            defined_theme +
            theme(legend.title = element_text(size = 10,
                                              hjust = 1, vjust=0.8),
                legend.position = "bottom",
                aspect.ratio = 7/10,
                legend.text = element_text(size = 9),
                strip.text = element_blank(),
                strip.background = element_blank())

p1

```

## Negative control codewords

Negative control codewords are unused barcode sequences included to detect random or erroneous decoding events, providing a measure of decoding noise. There are 41 codeword targets used in this dataset, and the overall detection profiles were consistent across the three replicates. The median total detections per codeword ranged from approximately 40 to 65, with replicate 1 showing slightly lower counts and replicate 3 showing the highest overall detection levels. The codewords appear randomly distributed across the tissue sections.
```{r nc_codeword, fig.width=12, fig.height=10}

codeword_coords <- as.data.frame(rbind(cbind(sample="replicate1",
                                             rep1$trans_info[rep1$trans_info$feature_name %in% rep1$codeword, c("feature_name","x","y")]),
                                        cbind(sample="replicate2",rep2$trans_info[rep2$trans_info$feature_name %in% rep2$codeword, c("feature_name","x","y")]),
                                        cbind(sample="replicate3",rep3$trans_info[rep3$trans_info$feature_name %in% rep3$codeword, c("feature_name","x","y")])
                                        ))
ordered_feature = codeword_coords %>% group_by(feature_name) %>% count() %>% arrange(desc(n))%>% pull(feature_name) 
codeword_tb = as.data.frame(codeword_coords %>% group_by(sample, feature_name) %>% count())
colnames(codeword_tb) = c("sample","feature_name","value_count")
codeword_tb$feature_name = factor(codeword_tb$feature_name, levels= ordered_feature)

codeword_tb = codeword_tb[order(codeword_tb$feature_name), ]

ggplot(codeword_tb, aes(x = feature_name, y = value_count)) +
    geom_bar(stat = "identity", position = position_dodge()) + 
    facet_wrap(~sample, ncol=1, scales = "free_y")+
    labs(title = " ", x = " ", y = "Number of total detections") +
    theme_bw()+
    theme(legend.position = "none",
          axis.text.x= element_text(size=8, angle=45,vjust=1,hjust = 1),
          axis.text.y=element_text(size=10),
          axis.ticks=element_blank(),
          strip.text = element_text(size=12),
          axis.title.y = element_text(size=12),
          axis.title.x=element_blank(),
          strip.background = element_rect(fill="white", colour ="black"),
          panel.background=element_blank(),
          panel.grid.minor=element_blank(),
          plot.background=element_blank())

```

```{r nc_codeword_xy, fig.height=5, fig.width=9}
p2<- ggplot(codeword_coords, aes(x = x, y = y)) +
            geom_hex(bins = auto_hex_bin(min(table(probe_coords$sample)), 
                                         target_points_per_bin = 1)) +
            theme_bw() +
            scale_fill_gradient(low = "white", high = "black") +
            guides(fill = guide_colorbar(barheight = unit(0.06, "npc"),
                                         barwidth  = unit(0.4, "npc"),
                                         )) +
            scale_x_reverse()+
            facet_grid(~sample) +
            defined_theme +
            theme(legend.title = element_text(size = 10, hjust = 1, vjust=0.8),
                legend.position = "bottom",
                aspect.ratio = 7/10,
                legend.text = element_text(size = 9),
                strip.text = element_blank(),
                strip.background = element_blank())

p2

```

# Banksy clustering

We combined the three replicates into a single SpatialExperiment object after assigning unique cell IDs and log-normalizing the data through Seurat. BANKSY was then run with λ = 0.2 and k_geom = 15, using adaptive geometric features to capture local spatial context. We performed dimensional reduction (PCA and UMAP) and clustered the data at resolutions 0.1. The resulting clusters were merged across samples to obtain consistent labels for marker detection and annotation.
```{r banksy-workflow, fig.width=9,fig.height=6, eval=FALSE}
# List of source directories
sps <- c("1", "2", "3")

spe_list <- lapply(sps, function(id) {
    rp =  get(paste0("rep", id))
    cell_info <-rp$cell_info
    cell_info$cells = paste0("r", id, "-",cell_info$cell_id)
    cm <-get(paste0("cm", id))
    # Subset and rename cells
    sub_info <- cell_info[, c("x_centroid", "y_centroid", "cells")]
    colnames(sub_info) = c("x", "y", "cells")
    rownames(sub_info) <- sub_info$cells
    sub_info = sub_info[colnames(cm),]
    coords <- as.matrix(sub_info[, c("x", "y")])
    
    # Construct SpatialExperiment
    SpatialExperiment(
        assays = list(counts = cm),
        spatialCoords = coords,
        sample_id = paste0("replicate",as.character(id))
    )
})

se <- do.call(cbind, spe_list)

# Convert to Seurat and normalize
seu <- as.Seurat(se, data = NULL)
seu <- NormalizeData(seu, normalization.method = "LogNormalize")
seu <- FindVariableFeatures(seu, nfeatures = nrow(seu))

# Back to SpatialExperiment
aname <- "logcounts"
# assay(se, aname) <- GetAssayData(seu)

logcounts_mat <- GetAssayData(seu, slot = "data")[, colnames(se)]
assay(se, "logcounts", withDimnames = FALSE) <- logcounts_mat


# Re-split by sample
spe_list <- split(seq_len(ncol(se)), se$sample_id) |>
    lapply(function(cols) se[, cols])

lambda <- c(0.2)
k_geom <- 15
use_agf <- TRUE
compute_agf <- TRUE

spe_list <- lapply(spe_list, computeBanksy, assay_name = aname, 
                   compute_agf = compute_agf, k_geom = k_geom)

spe_joint <- do.call(cbind, spe_list)

spe_joint <- runBanksyPCA(spe_joint, use_agf = use_agf, 
                          lambda = lambda, group = "sample_id", seed = 1000)

spe_joint <- runBanksyUMAP(spe_joint, use_agf = use_agf, 
                           lambda = lambda, seed = 1000)

cat("Clustering starts\n")
spe_joint <- clusterBanksy(spe_joint, use_agf = use_agf, lambda = lambda,
                           resolution = c(0.1, 0.5), seed = 1000)

spe_joint <- connectClusters(spe_joint)

cluster_info <- data.frame(
    x = spatialCoords(spe_joint)[, 1],
    y = spatialCoords(spe_joint)[, 2],
    cell_id = colnames(spe_joint), 
    cluster = paste0("c", colData(spe_joint)$clust_M1_lam0.2_k50_res0.1),  
    sample = colData(spe_joint)$sample_id
)

saveRDS(seu, here(gdata,paste0(data_nm, "_seu.Rds")))
saveRDS(spe_joint, here(gdata,paste0(data_nm, "_se.Rds")))
saveRDS(cluster_info, here(gdata,paste0(data_nm, "_clusters.Rds")))

```

```{r load processed data}
# load generated data  (see code above for how they were created)
cluster_info = readRDS(here(gdata,paste0(data_nm, "_clusters.Rds")))
cluster_names = paste0("c",1:9)

fig_ratio = cluster_info %>%
  group_by(sample) %>%
  summarise(
    x_range = diff(range(x, na.rm = TRUE)),
    y_range = diff(range(y, na.rm = TRUE)),
    ratio   = y_range / x_range,
    .groups = "drop"
  ) %>% summarise(max_ratio = max(ratio)) %>%  pull(max_ratio)

seu = readRDS(here(gdata,paste0(data_nm, "_seu.Rds")))
se = readRDS(here(gdata,paste0(data_nm, "_se.Rds")))

Idents(seu)=cluster_info$cluster[match(colnames(seu), cluster_info$cell_id)]
Idents(seu) = factor(Idents(seu), levels = cluster_names)
seu$sample = cluster_info$sample[match(colnames(seu), cluster_info$cell_id)]
```

There are 162,033, 154,654, and 158,047 cells in replicates 1, 2, and 3 respectively. The relative cluster proportions are consistent across all three replicates. Clusters c1, c2, and c3 are the largest, together accounting for over 70% of all cells in each replicate. In contrast, smaller clusters such as c8 and c9 contian only around 1.2%-1.5% of total cells.
```{r ct_prop, fig.width=10, fig.height=5}

sum_df = cluster_info[,c("cluster", "cell_id","sample"),drop=FALSE] %>% 
    group_by(cluster, sample) %>% dplyr::count()

ggplot(sum_df, aes(x = cluster, y = n, fill=sample)) +
  geom_bar(stat="identity", position=position_dodge()) +
  scale_y_continuous(expand = c(0,10), limits = c(0, 1.1*max(sum_df$n)))+
  labs(title = " ", x = "cluster", y = "number of cells", fill=" ") +
  theme_bw()+
   theme(legend.position = "top",
         axis.text= element_text(size=12),
         axis.title.y = element_text(size=12),
         axis.title.x = element_blank(),
         legend.text = element_text(size=12),
         strip.text = element_text(size = rel(1))
         )
```

## Cluster visualisation
Whole-sample view of every mouse brain replicate, colored by cluster. The tissue architecture is well preserved, with major brain structures clearly visible.
```{r clusters-vis-xy-whole, fig.width= 10, fig.height= 5}
p1<- ggplot(data = cluster_info,aes(x = x, y = y, color=cluster))+
        geom_point(size=0.001, alpha=0.4)+
        facet_wrap(~sample, ncol=3)+
        scale_x_reverse()+
        theme_classic()+
        guides(color=guide_legend(title="", nrow = 1,
        override.aes=list(alpha=1, size=4)))+
        defined_theme + theme(aspect.ratio = fig_ratio,,
                              legend.position = "top", 
                              legend.text = element_text(size=15),
                              strip.background = element_blank(),
                              strip.text = element_text(size = rel(1.2)))
p1
```

Cluster-specific views showing that most clusters are spatially separable. 
```{r clusters-vis-xy-percluster, fig.width= 15, fig.height= 15}
p1<- ggplot(data = cluster_info[cluster_info$sample=="replicate1", ],
        aes(x = x, y = y, color=cluster))+
        geom_point(size=0.001)+
        facet_wrap(~cluster, ncol=5)+
        scale_x_reverse()+
        scale_color_manual(values = my_colors)+
        theme_minimal()+
        defined_theme+
        labs(title = "Mouse brain replicate1")+
        theme(aspect.ratio = fig_ratio,
               plot.title = element_text(size = rel(1.6),hjust = 0),
              strip.text = element_text(size = rel(1.2)))


p2<- ggplot(data = cluster_info[cluster_info$sample=="replicate2", ],
        aes(x = x, y = y, color=cluster))+
        geom_point(size=0.001)+
        facet_wrap(~cluster, ncol=5)+
        scale_x_reverse()+
        scale_color_manual(values = my_colors)+
        theme_minimal()+
        defined_theme+
        labs(title = "Mouse brain replicate2")+
        theme(aspect.ratio =fig_ratio,
              plot.title = element_text(size = rel(1.6),hjust = 0),
              strip.text = element_text(size = rel(1.2)))

p3<- ggplot(data = cluster_info[cluster_info$sample=="replicate3", ],
        aes(x = x, y = y, color=cluster))+
        geom_point(size=0.001)+
        facet_wrap(~cluster, ncol=5)+
        scale_x_reverse()+
        scale_color_manual(values = my_colors)+
        theme_minimal()+
        defined_theme+
        labs(title = "Mouse brain replicate3")+
        theme(aspect.ratio =fig_ratio,
              plot.title = element_text(size = rel(1.6), hjust = 0),
              strip.text = element_text(size = rel(1.2)))

layout_design <- p1 / p2 / p3
layout_design
```


# Detect marker genes 
## jazzPanda

We applied jazzPanda to this dataset using the linear modelling approach to detect spatially enriched marker genes across clusters. The dataset was converted into spatial gene and cluster vectors using a 50 × 50 square binning strategy. Transcript detections for the negative control probes and codewords targets were included as the background control. For each gene, a linear model was fitted to estimate its spatial association with relevant cell type patterns. 
```{r jazzPanda-glm, eval=FALSE}

all_genes =row.names(rep1$cm)
grid_length=50

# get spatial vectors
all_vectors = get_vectors(x= list("replicate1" = rep1$trans_info,
                                  "replicate2" = rep2$trans_info,
                                  "replicate3" = rep3$trans_info), 
                          sample_names=c("replicate1","replicate2","replicate3"),
                          cluster_info = cluster_info, bin_type="square",
                          bin_param=c(grid_length,grid_length), 
                          test_genes = all_genes , 
                          n_cores = 5)

nc_vectors = create_genesets(x=list("replicate1" = rep1$trans_info,
                                    "replicate2" = rep2$trans_info,
                                    "replicate3" = rep3$trans_info), 
                             sample_names=c("replicate1","replicate2","replicate3"),
                             name_lst=list(probe=rep1$probe, 
                                           codeword=rep1$codeword),
                             bin_type="square",
                             bin_param=c(grid_length,grid_length), 
                             cluster_info = NULL)
})


set.seed(188)
jazzPanda_res_lst = lasso_markers(gene_mt=all_vectors$gene_mt,
                                  cluster_mt = all_vectors$cluster_mt,
                                  sample_names=c("replicate1","replicate2","replicate3"),
                                  keep_positive=TRUE, 
                                  background=nc_vectors)

saveRDS(all_vectors, here(gdata,paste0(data_nm, "_sq50_vector_lst.Rds")))
saveRDS(jazzPanda_res_lst, here(gdata,paste0(data_nm, "_jazzPanda_res_lst.Rds")))
```

```{r load generated jazzPanda}
# load generated data  (see code above for how they were created)
jazzPanda_res_lst = readRDS(here(gdata,paste0(data_nm, "_jazzPanda_res_lst.Rds")))
nbins = 2500
sv_lst = readRDS(here(gdata,paste0(data_nm, "_sq50_vector_lst.Rds")))

jazzPanda_res = get_top_mg(jazzPanda_res_lst, coef_cutoff=0.1)  
jazzPanda_summary = as.data.frame(table(jazzPanda_res$top_cluster))
colnames(jazzPanda_summary) = c("cluster","jazzPanda_glm")

```

This dotplot shows the top 10 marker genes per cluster identified using the linear modelling approach.  Some clusters (such as c7 and c9) display relatively distinct marker profiles with strong and specific expression signals. In contrast, clusters like c3 show some overlap in gene expression, with markers moderately expressed across multiple clusters rather than being cluster-restricted.
```{r top10_glm,fig.width=8, fig.height=16}
glm_mg = jazzPanda_res[jazzPanda_res$top_cluster != "NoSig", ]
glm_mg$top_cluster = factor(glm_mg$top_cluster, levels = cluster_names)
top_mg_glm <- glm_mg %>%
  group_by(top_cluster) %>%
  arrange(desc(glm_coef), .by_group = TRUE) %>% 
  slice_max(order_by = glm_coef, n = 10) %>%
  select(top_cluster, gene, glm_coef)

p1<-DotPlot(seu, features = top_mg_glm$gene) +
     scale_colour_gradient(low = "white", high = "red") +
    coord_flip()+
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))+
    labs(title = "Top 10 marker genes (jazzPanda-glm)", x="", y="")

p1
```

### Cluster to cluster correlation

We computed pairwise Spearman correlations between spatial cluster vectors to assess relationships among clusters for every replicate. Overall, the pairwise correlations are generally low, indicating that most clusters occupy distinct spatial regions. The highest correlations (≈0.45–0.47) are observed between clusters c1 and c3, which show partially overlapping spatial patterns.

```{r cc-corr, fig.width=6, fig.height=6}
for (curr_sp in c("replicate1", "replicate2", "replicate3")){
    
    cluster_mtt <- sv_lst$cluster_mt[sv_lst$cluster_mt[, curr_sp] == 1, ]
    cluster_mtt <- cluster_mtt[, cluster_names]
    cor_M_cluster <- cor(cluster_mtt, cluster_mtt, method = "spearman")
    
    col <- colorRampPalette(c("#4477AA", "#77AADD", "#FFFFFF",
                              "#EE9988", "#BB4444"))
    
    corrplot(cor_M_cluster,
            method = "color",
            col = col(200),
            diag = TRUE,
            addCoef.col = "black",
            type = "upper",
            tl.col = "black",
            tl.cex = 1,
            number.cex = 0.8,
            tl.srt = 0,
            mar = c(0, 0, 3, 0),   
            sig.level = 0.05,
            insig = "blank")
    
    title(paste(curr_sp, "cluster–cluster correlation"),
            line = 1,               
            cex.main = 1.2)

}
```

```{r, output_markergenes_jazzPanda}

# Combine into a new dataframe for LaTeX output
output_data <- do.call(rbind, lapply(cluster_names, function(cl) {
  subset <- jazzPanda_res[jazzPanda_res$top_cluster == cl, ]
  sorted_subset <- subset[order(-subset$glm_coef), ]
  gene_list <- paste(sorted_subset$gene, "(", round(sorted_subset$glm_coef, 2), ")", sep="", collapse=", ")
 
  return(data.frame(Cluster = cl, Genes = gene_list))
}))

latex_table <- xtable(output_data, caption="Detected marker genes for each cluster by jazzPanda, in decreasing value of glm coefficients")
print.xtable(latex_table, include.rownames = FALSE, hline.after = c(-1, 0, nrow(output_data)), comment = FALSE)
```

### Top3 marker genes by jazzPanda_glm

We visualized the top three marker genes identified by the linear modelling approach for each cluster. For each selected gene, its spatial transcript locations were plotted alongside the corresponding cluster map. Across clusters, the spatial expression patterns of marker genes closely match the distribution of their associated cluster. 

```{r  top3-gene-vis-xy, fig.width=10, fig.height=6}
x_range <- c(0, 11000)
y_range <- c(0, 7500)

plot_lst=list()
for (cl in cluster_names){
    inters=jazzPanda_res[jazzPanda_res$top_cluster==cl,"gene"]
    rounded_val=signif(as.numeric(jazzPanda_res[inters,"glm_coef"]),
                          digits = 3)
    inters_df = as.data.frame(cbind(gene=inters, value=rounded_val))
    inters_df$value = as.numeric(inters_df$value)
    inters_df=inters_df[order(inters_df$value, decreasing = TRUE),]
    inters_df$text= paste(inters_df$gene,inters_df$value,sep=": ")
    
    if (length(inters > 0)){
        inters_df = inters_df[1:min(3, nrow(inters_df)),]
        inters = inters_df$gene
        all_trans = as.data.frame(matrix(0, ncol=6))
        colnames(all_trans) = c("x","y", "feature_name","value","text_label","sample")
        for (rp in c("rep1","rep2","rep3")){
          rp_lst = get(rp)
          iters_sp1= rp_lst$trans_info$feature_name %in% inters
          vis_r1 =rp_lst$trans_info[iters_sp1,
                            c("x","y","feature_name")]
          vis_r1$value = inters_df[match(vis_r1$feature_name,inters_df$gene),
                            "value"]
          vis_r1=vis_r1[order(vis_r1$value,decreasing = TRUE),]
          vis_r1$text_label= paste(vis_r1$feature_name,
                                vis_r1$value,sep=": ")
          vis_r1$text_label=factor(vis_r1$text_label, levels=inters_df$text)
          vis_r1$sample=paste("replicate", substr(rp,start = 4, stop=4),sep="")
          all_trans = rbind(all_trans,vis_r1)
        }
        all_trans = all_trans[2:nrow(all_trans),]
        all_trans$text_label = factor(all_trans$text_label, 
                                      levels = inters_df$text)
        all_trans = all_trans[order(all_trans$text_label),]

        genes_plt<- ggplot(data = all_trans,
                    aes(x = x, y = y))+ 
                    geom_hex(bins = auto_hex_bin(mean(table(all_trans$sample, 
                                                            all_trans$feature_name))))+
                    facet_grid(sample~text_label)+
                    scale_x_reverse() +
                    scale_fill_gradient(low="white", high="maroon4") + 
                    guides(fill = guide_colorbar(barheight = unit(0.2, "npc"), 
                                                 barwidth  = unit(0.03, "npc")))+
                    defined_theme+
            theme(legend.position = "right", 
              strip.background = element_rect(fill =NA,colour = NA),
              strip.text = element_text(size = rel(1.3)), 
              strip.text.y.right = element_blank(),
              legend.key.width = unit(2, "cm"),
              aspect.ratio = fig_ratio,
              legend.title = element_text(size = 10),
              legend.text = element_text(size = 10),
               legend.key.height = unit(2, "cm"))
        
        cluster_data =  cluster_info[cluster_info$cluster==cl, ]
        cluster_data$label = paste(cluster_data$sample, cluster_data$cluster, sep="-")
        cluster_data$label =factor(cluster_data$label, 
                                   levels=paste(paste("replicate",1:3,sep=""),
                                                cl,sep="-"))
        p_cl<- ggplot(data =cluster_data,
                    aes(x = x, y = y, color=sample))+ 
                    geom_point(size=0.01)+
                    facet_wrap(~label, nrow=3,strip.position = "left")+
                    scale_x_reverse(limits = rev(x_range)) +  # enforce global x
                    scale_y_continuous(limits = y_range) +  # enforce global y

                    scale_color_manual(values = c("black","black","black"))+
                    defined_theme + 
            theme(legend.position = "none", 
                  strip.background = element_blank(), 
                  aspect.ratio = fig_ratio,
                  legend.key.width = unit(15, "cm"),
                  strip.text = element_text(size = rel(1.2)))

        lyt <-p_cl | genes_plt
        layout_design <- lyt + patchwork::plot_layout(heights = c(1,1),
                                                      widths = c(1, 3)) 
        print(layout_design)

    }
  }


```

### Cluster vector versus marker gene vector 

We visualized the top three marker genes for each cluster by plotting their spatial gene vectors against the corresponding cluster vector. Each scatter plot shows how strongly each marker gene’s spatial pattern aligns with the overall spatial signal of its cluster, allowing assessment of both marker specificity and coherence with spatial domains.

For all clusters, marker genes show a strong positive trend with the corresponding cluster vector, confirming that their expression is spatially aligned with the inferred cluster domain.
```{r vvplot,fig.width=12, fig.height=12}
plot_lst=list()
for (cl in cluster_names){
    inters_df=jazzPanda_res[jazzPanda_res$top_cluster==cl,]

    inters_df=inters_df[order(inters_df$glm_coef, decreasing = TRUE),]
    
    inters_df = inters_df[1:min(3, nrow(inters_df)),]
    mk_genes = inters_df$gene

    dff = as.data.frame(cbind(sv_lst$cluster_mt[,cl],
                              sv_lst$gene_mt[,mk_genes]))
    colnames(dff) = c("cluster", mk_genes)
    dff$sample= "replicate1"
    dff[nbins:(nbins*2),"sample"] = "replicate2"
    dff[(nbins*2):(nbins*3),"sample"] = "replicate3"
    dff$vector_id = c(1:nbins, 1:nbins, 1:nbins)
    long_df <- dff %>% 
    tidyr::pivot_longer(cols = -c(cluster, sample, vector_id), 
                        names_to = "gene", 
               values_to = "vector_count")
    long_df$gene = factor(long_df$gene, levels=mk_genes)
    long_df$sample = factor(long_df$sample , 
                        levels=c("replicate1","replicate2", "replicate3"))
    p<-ggplot(long_df, aes(x = cluster, y = vector_count, color=gene )) +
    geom_point(size=0.01) +
    facet_grid(sample~gene, scales="free_y") +
    labs(x = paste(cl, " cluster vector ", sep=""), 
         y = "Top3 marker gene vector") +
    theme_minimal()+
        scale_y_continuous(expand = c(0.01,0.01))+ 
        scale_x_continuous(expand =  c(0.01,0.01))+ 
        theme(panel.grid = element_blank(),legend.position = "none",
        strip.text = element_text(size = 12),
        axis.line=element_blank(),
        axis.text=element_text(size = 9),
        axis.ticks=element_line(color="black"),
        axis.title=element_text(size = 13),
        panel.border  =element_rect(colour = "black", 
                                    fill=NA, linewidth=0.5)
        )
    plot_lst[[cl]] = p
}

combined_plot <- wrap_plots(plot_lst, ncol = 3)

combined_plot 


```

### Marker gene summary per cluster

For each cluster, we summarized the detected marker genes and their corresponding strengths. We list genes with model coefficients above the defined cutoff (e.g. 0.1) for each cluster.

Cluster c1 shows enrichment for Id2, Lamp5, and Cplx3, consistent with VIP/LAMP5 interneurons, though some mixed excitatory markers suggest partial transcriptional overlap. Cluster c2 expresses Opalin, Gjc3, and Sox10, clearly corresponding to myelinating oligodendrocytes (MOL).
Cluster c3 (Bhlhe22, Hpcal1, Nr2f2) matches IT-L2/3 excitatory neurons, while cluster c4 (Slc17a6, Foxp2, Ntsr2) represents layer 6 corticothalamic (L6 CT-like) neurons. Cluster c5 is dominated by Igf2, Gfap, and Aqp4, marking choroid plexus and glial-enriched regions with broad non-neuronal signatures. Cluster c6 (Ppp1r1b, Gad1, Penk) fits medium spiny neurons (MSNs) of GABAergic lineage. Cluster c7 (Prox1, Calb1) corresponds to dentate gyrus granule cells, whereas cluster c8 (Neurod6, Wfs1, Shisa6) identifies deep-layer IT-L6/CC projection neurons. Finally, c9 shows Chat, Sncg, and Syt6, consistent with ChAT⁺/SNCG⁺ interneurons.
```{r, output_markergenes_glm}
## linear modelling 
output_data <- do.call(rbind, lapply(cluster_names, function(cl) {
  subset <- jazzPanda_res[jazzPanda_res$top_cluster == cl, ]
  sorted_subset <- subset[order(-subset$glm_coef), ]
  if (length(sorted_subset) == 0){
    return(data.frame(Cluster = cl, Genes = "  "))
  }
  if (cl != "NoSig"){
    gene_list <- paste(sorted_subset$gene, "(", round(sorted_subset$glm_coef, 2), ")", sep="", collapse=", ")
  }else{
    gene_list <- paste(sorted_subset$gene, "", sep="", collapse=", ")
  }
  
  return(data.frame(Cluster = cl, Genes = gene_list))
}))

knitr::kable(
  output_data,
  caption = "Detected marker genes for each cluster by linear modelling approach in jazzPanda, in decreasing value of glm coefficients"
)
```

### Nosig genes 

These five genes (Cd300c2, Ikzf1, Slc6a3, Spi1, and Th) show low or spatially restricted expression across replicates. Their known biology suggests that most are associated with immune or dopaminergic lineages, which are not well represented among the nine annotated cortical and hippocampal cell types. The weak and patchy expression patterns observed here are therefore expected, and it is reasonable that our method did not identify them as cluster-defining marker genes.
```{r Nosig-genes,fig.width=10, fig.height=6}
cl="NoSig"
inters=jazzPanda_res[jazzPanda_res$top_cluster==cl,"gene"]
all_trans = as.data.frame(matrix(0, ncol=4))
colnames(all_trans) = c("x","y", "feature_name","sample")
for (rp in c("rep1","rep2","rep3")){
  rp_lst = get(rp)
  iters_sp1= rp_lst$trans_info$feature_name %in% inters
  vis_r1 =rp_lst$trans_info[iters_sp1,
                    c("x","y","feature_name")]
  vis_r1$sample=paste("replicate", substr(rp,start = 4, stop=4),sep="")
  all_trans = rbind(all_trans,vis_r1)
}
all_trans = all_trans[2:nrow(all_trans),]


genes_plt<- ggplot(data = all_trans,
            aes(x = x, y = y))+ 
            geom_point(size=0.001, alpha=0.5)+
            facet_grid(sample~feature_name)+
            scale_x_reverse()+
            guides(fill = guide_colorbar(barwidth = unit(15, "cm"), 
                                         height= unit(15, "cm")))+
            defined_theme+ theme(legend.position = "bottom", 
                      strip.background = element_rect(fill = "white",
                                                      colour = "black"),
                      strip.text = element_text(size = rel(1.2)), 
                      legend.key.width = unit(2, "cm"),
                      legend.title = element_text(size = 10),
                      legend.text = element_text(size = 10),
                       legend.key.height = unit(2, "cm"))
        
genes_plt

```

## Wilcoxon Rank Sum Test

The `FindAllMarkers` function applies a Wilcoxon Rank Sum test to detect genes with cluster-specific expression shifts. Only positive markers (upregulated genes) were retained using a log fold-change threshold of 0.1

```{r fm-mg, eval=FALSE}
seu = readRDS(here(gdata,paste0(data_nm, "_seu.Rds")))
rownames(cluster_info) <- cluster_info$cell_id

# Reorder clusters$cluster to match Seurat cells
Idents(seu) <- cluster_info$cluster[match(colnames(seu), rownames(cluster_info))]
find_markers_result <- FindAllMarkers(seu, only.pos = TRUE,
                                      logfc.threshold = 0.1)
table(find_markers_result$cluster)
saveRDS(find_markers_result, here(gdata,paste0(data_nm, "_seu_markers.Rds")))
```

```{r load_FM_res, fig.width=8, fig.height=12}

FM_result= readRDS(here(gdata,paste0(data_nm, "_seu_markers.Rds")))
FM_result = FM_result[FM_result$avg_log2FC>0.1, ]

table(FM_result$cluster)
FM_result$cluster <- factor(FM_result$cluster,
                            levels = cluster_names)

top_mg <- FM_result %>%
  group_by(cluster) %>%
  arrange(desc(avg_log2FC), .by_group = TRUE) %>% 
  slice_max(order_by = avg_log2FC, n = 10) %>%
  select(cluster, gene, avg_log2FC)

p1<-DotPlot(seu, features = unique(top_mg$gene)) +
     scale_colour_gradient(low = "white", high = "red") +
    coord_flip()+
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))+
    labs(title = "Top 10 marker genes (WRS)", x="", y="")

p1

```

## limma

We applied the limma framework to identify differentially expressed marker genes across clusters in the healthy liver sample. Count data were normalized using log-transformed counts from the speckle package. A linear model was fitted for each gene with cluster identity as the design factor, and pairwise contrasts were constructed to compare each cluster against all others. Empirical Bayes moderation was applied to stabilize variance estimates, and significant genes were determined using the moderated t-statistics from eBayes.

```{r limma-mg, eval=FALSE}

all.bct <- factor(cluster_info$cluster)
sample <- spe_joint$sample_id
y <- DGEList(cbind(cm1, cm2, cm3))
y$genes <-row.names(rep1$cm)

logcounts.all <- normCounts(y,log=TRUE,prior.count=0.1)

design <- model.matrix(~0+all.bct+sample)
colnames(design)[1:(length(levels(all.bct)))] <- levels(all.bct)

mycont <- matrix(0,ncol=length(levels(all.bct)),nrow=length(levels(all.bct)))
colnames(mycont)<-levels(all.bct)
diag(mycont)<-1
mycont[upper.tri(mycont)]<- -1/(length(levels(all.bct))-1)
mycont[lower.tri(mycont)]<- -1/(length(levels(all.bct))-1)

# Fill out remaining rows with 0s
zero.rows <- matrix(0,ncol=length(levels(all.bct)),nrow=(ncol(design)-length(levels(all.bct))))
test <- rbind(mycont,zero.rows)
fit <- lmFit(logcounts.all,design)
fit.cont <- contrasts.fit(fit,contrasts=test)
fit.cont <- eBayes(fit.cont,trend=TRUE,robust=TRUE)

fit.cont$genes <-row.names(rep1$cm)
limma_dt <- decideTests(fit.cont)
saveRDS(fit.cont, here(gdata,paste0(data_nm, "_fit_cont_obj.Rds")))
```


```{r looad_limma_res, fig.width=8, fig.height=14}
fit.cont = readRDS(here(gdata,paste0(data_nm, "_fit_cont_obj.Rds")))
limma_dt <- decideTests(fit.cont)
summary(limma_dt)

top_markers <- lapply(cluster_names, function(cl) {
  tt <- topTable(fit.cont,
                 coef = cl,
                 number = Inf,
                 adjust.method = "BH",
                 sort.by = "P")
  tt <- tt[order(tt$adj.P.Val, -abs(tt$logFC)), ]   # tie-break by logFC
  tt$contrast <- cl
  tt$gene <- rownames(tt)
  head(tt, 10)   # top 10
})


# Combine into one data.frame
top_markers_df <- bind_rows(top_markers) %>%
  select(contrast, gene, logFC, adj.P.Val)


p1<- DotPlot(seu, features = unique(top_markers_df$gene)) +
     scale_colour_gradient(low = "white", high = "red") +
    coord_flip()+
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))+
    labs(title = "Top 10 marker genes (limma)", x="", y="")

p1
```

# Comparison of marker gene detection methods
## Cumulative rank plot

We compared the performance of different marker detection methods — jazzPanda (linear modelling), limma, and Seurat’s Wilcoxon Rank Sum test — by evaluating the cumulative average spatial correlation between ranked marker genes and their corresponding target clusters at the spatial vector level.

We can see that the linear modelling approach prioritizes highly correlated marker genes more effectively than the other two methods. 
```{r cmr plot, fig.width=12, fig.height=12}
plot_lst=list()

cor1 <- cor(sv_lst$gene_mt[1:2500, ],
            sv_lst$cluster_mt[1:2500, cluster_names], method = "spearman")

cor2 <- cor(sv_lst$gene_mt[2500:5000, ],
            sv_lst$cluster_mt[2500:5000, cluster_names], method = "spearman")

cor3 <- cor(sv_lst$gene_mt[5000:7500, ],
            sv_lst$cluster_mt[5000:7500, cluster_names], method = "spearman")

cor_M <-(cor1 + cor2 + cor3) / 3


Idents(seu)=cluster_info$cluster[match(colnames(seu), cluster_info$cell_id)]
for (cl in cluster_names){
    fm_cl=FindMarkers(seu, ident.1 = cl, only.pos = TRUE,
            logfc.threshold = 0.1)
    fm_cl = fm_cl[fm_cl$p_val_adj<0.05, ]
    fm_cl = fm_cl[order(fm_cl$avg_log2FC, decreasing = TRUE),]
    to_plot_fm =row.names(fm_cl)

    
    limma_cl<-topTable(fit.cont,coef=cl,p.value = 0.05, n=Inf, sort.by = "p")
    limma_cl = limma_cl[limma_cl$logFC>0, ]
    to_plot_lm = row.names(limma_cl)
    
    
    lasso_sig = jazzPanda_res[jazzPanda_res$top_cluster==cl,]
    lasso_sig = lasso_sig[order(lasso_sig$glm_coef, decreasing = TRUE),]
    
    FM_pt = data.frame("name"=to_plot_fm,"rk"= 1:length(to_plot_fm),
                       "y"= get_cmr_ma(to_plot_fm,cor_M = cor_M, cl = cl),
                       "type"="Wilcoxon Rank Sum Test")
    
    
    lasso_pt = data.frame("name"=lasso_sig$gene,"rk"= 1:nrow(lasso_sig),
                          "y"= get_cmr_ma(lasso_sig$gene,cor_M = cor_M, cl = cl),
                          "type"="jazzPanda-glm")
    
    limma_pt = data.frame("name"=to_plot_lm,"rk"= 1:length(to_plot_lm),
                          "y"= get_cmr_ma(to_plot_lm,cor_M = cor_M, cl = cl),
                          "type"="limma")
  
    data_lst = rbind(limma_pt, lasso_pt,FM_pt)

    data_lst$type <- factor(
        data_lst$type,
        levels = c("jazzPanda-glm", "limma", "Wilcoxon Rank Sum Test")
    )
    data_lst$rk = as.numeric(data_lst$rk)
    p <-ggplot(data_lst, aes(x = rk, y = y, color = type)) +
        geom_step(size = 0.8) +  # type = "s"
        scale_color_manual(values = c("jazzPanda-glm" = "red",
                                      "limma" = "black",
                                      "Wilcoxon Rank Sum Test" = "blue")) +
        labs(title = paste0("Cluster: ", cl), x = "Rank of marker genes",
             y = "Cumulative average correlation",
             color = NULL) +
        scale_x_continuous(limits = c(0, 50))+
        theme_classic(base_size = 12) +
        theme(plot.title = element_text(hjust = 0.5),
            axis.line = element_blank(),  
            panel.border = element_rect(color = "black", 
                                        fill = NA, linewidth = 1),
            legend.position = "inside",
            legend.position.inside = c(0.98, 0.02),
            legend.justification = c("right", "bottom"),
            legend.background = element_rect(color = "black", 
                                             fill = "white", linewidth = 0.5),
            legend.box.background = element_rect(color = "black",
                                                 linewidth = 0.5)
        )
    plot_lst[[cl]] <- p
}

combined_plot <- wrap_plots(plot_lst, ncol = 3)
combined_plot 


```

## Upset plot

We further visualized the overlap between marker genes detected by the four methods using UpSet plots for each cluster. While limma and the Wilcoxon rank-sum test detect a larger number of marker genes, many of these lack clear spatial relevance. In contrast, our method identifies a more refined and spatially coherent set of markers that align closely with cluster boundaries. The moderate overlaps with non-spatial methods suggest that our approach captures the most spatially informative gene. 

```{r upset-mg-comparison, fig.width=12, fig.height=12}
plot_lst=list()
for (cl in cluster_names){
    findM_sig <- FM_result[FM_result$cluster==cl & FM_result$p_val_adj<0.05,"gene"]
    limma_sig <- row.names(limma_dt[limma_dt[,cl]==1,])
    lasso_cl <- jazzPanda_res[jazzPanda_res$top_cluster==cl, "gene"]
    df_mt <- as.data.frame(matrix(FALSE,nrow=nrow(jazzPanda_res),ncol=3))
    row.names(df_mt) <- jazzPanda_res$gene
    colnames(df_mt) <- c("jazzPanda-glm",
                      "Wilcoxon Rank Sum Test","limma")
    df_mt[findM_sig,"Wilcoxon Rank Sum Test"] <- TRUE
    df_mt[limma_sig,"limma"] <- TRUE
    df_mt[lasso_cl,"jazzPanda-glm"] <- TRUE
    
    df_mt$gene_name <- row.names(df_mt)
    
    p = plot(upset(df_mt,
               intersect=c("Wilcoxon Rank Sum Test", "limma",
                           "jazzPanda-glm"),
               wrap=TRUE, keep_empty_groups= FALSE, name="",
               #themes=theme_grey(),
               stripes='white',
               sort_intersections_by ="cardinality", sort_sets= FALSE,min_degree=1,
               set_sizes =( 
                   upset_set_size()
                   + theme(axis.title= element_blank(),
                           axis.ticks.y = element_blank(),
                           axis.text.y = element_blank())),
               sort_intersections= "descending", warn_when_converting=FALSE,
               warn_when_dropping_groups=TRUE,encode_sets=TRUE,

               width_ratio=0.3, height_ratio=1/4)+
              ggtitle(paste0("Cluster: ", cl))+
                 theme(plot.title = element_text( size=15))

    )
         
    plot_lst[[cl]] <- p 
}


combined_plot <- wrap_plots(plot_lst, ncol = 3)

combined_plot 

```

# Annotate cell type with top marker genes 
```{r}
anno_df <- data.frame(
    cluster = cluster_names,
    major_class = c(
    "Inhibitory neuron",
    "Oligodendrocyte lineage",
    "Excitatory neuron",
    "Excitatory neuron",
    "Non-neuronal (barrier/stromal mix)",
    "Inhibitory projection neuron",
    "Excitatory neuron",
    "Excitatory neuron",
    "Cholinergic neuron"
  ),
  sub_class = c(
    "L2/3 LAMP5/VIP interneuron",
    "Mature oligodendrocyte (myelinating)",
    "IT L2/3",
    "Corticothalamic-like",
    "Choroid plexus & vascular/stromal admixture",
    "Striatal medium spiny neuron (MSN)",
    "Dentate gyrus granule",
    "IT L6 corticocortical (Neurod6+)",
    "Cortical/striatal cholinergic interneuron"
  ),
  cell_type = c(
    "VIP/LAMP5 (CPLX3+, ID2+)",
    "MOL (Opalin+/Gjc3+/Sox10+)",
    "IT-L2/3 (BHLHE22+/HPcal1+)",
    "L6 CT-like (FOXP2+/NTSR2+/VGlut2+)",
    "Choroid plexus epithelium–enriched",
    "MSN (DARPP-32+, GABAergic)",
    "DG granule (Prox1+/Calb1+)",
    "IT-L6/CC (Neurod6+/Wfs1+/Shisa6+)",
    "ChAT+/SNCG+ interneuron"
  ),
  supporting_genes = c(
    "JP: Id2, Lamp5, Vip, Cplx3, Crh, Cort; FM: Lamp5, Vip, Cplx3, Satb2",
    "JP: Opalin, Gjc3, Sox10; FM: Opalin, Sox10, Gjc3, Spag16",
    "JP: Slc17a7, Bhlhe22, Hpcal1, Cdh13; FM: Cabp7, Bhlhe22, Syt17",
    "JP: Slc17a6, Foxp2, Ntsr2, Rims3; FM: Slc17a6, Foxp2, Rims3",
    "JP: Igf2, Slc13a4, Kdr, Pecam1, Emcn, Col1a1, Acta2; FM: Fmod, Aldh1a2, Igf2, Col1a1, Spp1",
    "JP: Ppp1r1b, Gad1/2, Penk, Pdyn, Meis2; FM: Penk, Pdyn, Ppp1r1b, Gad2",
    "JP: Prox1, Calb1, Prdm8; FM: Prox1, Calb1",
    "JP: Neurod6, Wfs1, Shisa6, Igfbp4; FM: Neurod6, Pou3f1, Shisa6, Wfs1",
    "JP: Chat, Sncg, Syt6; FM: Chat, Sncg, Tacr1, Kctd8"
  ),
  notes = c(
    "Robust LAMP5/VIP signal (Id2/Lamp5/Cplx3). SATB2/CUX2 likely ambient; minor immune genes likely contamination.",
    "Opalin+Gjc3+Sox10 define mature oligos; low Gpr17 argues against OPC.",
    "Slc17a7+ with IT adhesion/signaling genes; endothelial/immune hits in FM likely contaminants.",
    "Foxp2+Ntsr2+ with Slc17a6 (VGlut2) suggest L6 corticothalamic-like; some L4/5 IT (Rorb) admixture.",
    "Strong CP markers (Igf2, Slc13a4) with endothelial/smc/fibro mix → perivascular/meningeal CP neighborhood; ependymal Trp73 low.",
    "Classic MSN signature (DARPP-32 + Gad1/2 + Penk/Pdyn); indicates striatal tissue present.",
    "Prox1 hallmark of DG granule; Calb1 supportive.",
    "Canonical Neurod6 IT-L6 corticocortical program; small PT marker bleed-through possible.",
    "Clear ChAT/SNCG cholinergic identity; Syt6 hints at small L6 CT admixture."
  ),
  anno_name=c(
  "Inh_L23_LAMP5_VIP",        
  "Oligo_Mature_MOL",         
  "Exc_L23_IT",               
  "Exc_L6_CTlike",            
  "NonNeur_CP_VascStromal",   
  "Inh_Striatal_MSN",         
  "Exc_DG_Granule",           
  "Exc_L6_IT_CC",            
  "Cholin_ChAT_SNCG"),
  confidence = c(
    "Medium-High",
    "High",
    "Medium",
    "Medium",
    "Medium-Low",
    "High",
    "High",
    "Medium-High",
    "High"
  ),
  stringsAsFactors = FALSE
)

anno_df
```


```{r}
sessionInfo()
```

